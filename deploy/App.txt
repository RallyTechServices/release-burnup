<!DOCTYPE html>
<html>
<head>
    <title>Release Burnup</title>
    <!--  (c) 2016 CA Technologies.  All Rights Reserved. -->
    <!--  Build Date: Wed Jun 29 2016 12:07:03 GMT-0600 (MDT) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Wed Jun 29 2016 12:07:03 GMT-0600 (MDT)";
        var BUILDER = "kcorkan";
        var CHECKSUM = 37287640599;
    </script>
    
    <script type="text/javascript" src="/apps/2.1/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
    title: "Build Information",
    
    defaults: { padding: 5, margin: 5 },

    closable: true,
     
    draggable: true,

    autoShow: true,
   
    width: 350,
    
    informationalConfig: null,
    
    items: [{xtype:'container', itemId:'information' }],
    
    initComponent: function() {
        var id = Ext.id(this);
        this.title =  "<span class='icon-help'> </span>" + this.title;
        this.callParent(arguments);
    },
    
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/var BUILDER = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
       
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
   
        return chk;
    },
    
    _checkChecksum: function(container) {
        var deferred = Ext.create('Deft.Deferred');
        var me = this;
        
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    var stored_checksum = me._generateChecksum(text);
                    if ( CHECKSUM !== stored_checksum ) {
                        deferred.resolve(false);
                        return;
                    }
                }
                deferred.resolve(true);
            }
        });
        
        return deferred.promise;
    },
    
    _addToContainer: function(container){
        var config = Ext.apply({
            xtype:'container',
            height: 200,
            overflowY: true
        }, this.informationalConfig);
        
        container.add(config);
    },
    
    afterRender: function() {
        var app = Rally.getApp();
        
        if ( !Ext.isEmpty( this.informationalConfig ) ) {
            var container = this.down('#information');
            this._addToContainer(container);
            
        }
        
        if (! app.isExternal() ) {
            this._checkChecksum(app).then({
                scope: this,
                success: function(result){
                    if ( !result ) {
                        this.addDocked({
                            xtype:'container',
                            cls: 'build-info',
                            dock: 'bottom',
                            padding: 2,
                            html:'<span class="icon-warning"> </span>Checksums do not match'
                        });
                    }
                },
                failure: function(msg){
                    console.log("oops:",msg);
                }
            });
        } else {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                dock: 'bottom',
                html:'... Running externally'
            });
        }
        this.callParent(arguments);
    },
    
    beforeRender: function() {
        var me = this;
        this.callParent(arguments);

        if (this.informationHtml) {
            this.addDocked({
                xtype: 'component',
                componentCls: 'intro-panel',
                padding: 2,
                html: this.informationHtml,
                doc: 'top'
            });
        }
        
        this.addDocked({
            xtype:'container',
            cls: 'build-info',
            padding: 2,
            dock:'bottom',
            html:"This app was created by the CA AC Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                dock: 'bottom',
                html: Ext.String.format("Build date/time: {0} ({1})",
                    APP_BUILD_DATE,
                    BUILDER)
            });
        }
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

Ext.define('Rally.technicalservices.CustomStoreDropdown',{
    extend: 'Rally.ui.combobox.ComboBox',
    alias: 'widget.tscustomcombobox',

    constructor: function(config) {
        if (!config.valueField){
            config.valueField = 'value';
        }
        if (!config.displayField){
            config.displayField = config.valueField;
        }

        var storeData = config.allowedValues || [];
        if (storeData.length > 0 && Ext.isString(storeData[0])){
            storeData = _.map(storeData, function(item){
                var obj = {};
                obj[config.valueField] = item;
                return obj;
            });
        }
        console.log ('cfg',config, storeData);
        config.store = Ext.create('Ext.data.Store', {
            fields: [config.valueField],
            data: storeData
        });
        console.log ('cfg',config);
        return this.callParent([config]);
    }
});

Ext.define('CArABU.technicalservices.Exporter',{
    singleton: true,
    saveCSVToFile:function(csv,file_name,type_object){
        if (type_object === undefined){
            type_object = {type:'text/csv;charset=utf-8'};
        }
        this.saveAs(csv,file_name, type_object);
    },
    saveAs: function(textToWrite, fileName)
    {
        if (Ext.isIE9m){
            Rally.ui.notify.Notifier.showWarning({message: "Export is not supported for IE9 and below."});
            return;
        }

        var textFileAsBlob = null;
        try {
            textFileAsBlob = new Blob([textToWrite], {type:'text/plain'});
        }
        catch(e){
            window.BlobBuilder = window.BlobBuilder ||
                window.WebKitBlobBuilder ||
                window.MozBlobBuilder ||
                window.MSBlobBuilder;
            if (window.BlobBuilder && e.name === 'TypeError'){
                bb = new BlobBuilder();
                bb.append([textToWrite]);
                textFileAsBlob = bb.getBlob("text/plain");
            }

        }

        if (!textFileAsBlob){
            Rally.ui.notify.Notifier.showWarning({message: "Export is not supported for this browser."});
            return;
        }

        var fileNameToSaveAs = fileName;

        if (Ext.isIE10p){
            window.navigator.msSaveOrOpenBlob(textFileAsBlob,fileNameToSaveAs); // Now the user will have the option of clicking the Save button and the Open button.
            return;
        }

        var url = this.createObjectURL(textFileAsBlob);

        if (url){
            var downloadLink = document.createElement("a");
            if ("download" in downloadLink){
                downloadLink.download = fileNameToSaveAs;
            } else {
                //Open the file in a new tab
                downloadLink.target = "_blank";
            }

            downloadLink.innerHTML = "Download File";
            downloadLink.href = url;
            if (!Ext.isChrome){
                // Firefox requires the link to be added to the DOM
                // before it can be clicked.
                downloadLink.onclick = this.destroyClickedElement;
                downloadLink.style.display = "none";
                document.body.appendChild(downloadLink);
            }
            downloadLink.click();
        } else {
            Rally.ui.notify.Notifier.showError({message: "Export is not supported "});
        }

    },
    createObjectURL: function ( file ) {
        if ( window.webkitURL ) {
            return window.webkitURL.createObjectURL( file );
        } else if ( window.URL && window.URL.createObjectURL ) {
            return window.URL.createObjectURL( file );
        } else {
            return null;
        }
    },
    destroyClickedElement: function(event)
    {
        document.body.removeChild(event.target);
    }
});
Ext.define('Rally.technicalservices.ReleaseBurnupCalculator',{
    extend: 'Rally.data.lookback.calculator.TimeSeriesCalculator',
    config: {
        completedScheduleStateNames: ['Accepted'],
        usePoints: true,
        plannedPredictionLineName: "Prediction (Planned Points)",
        acceptedPredictionLineName: "Prediction (Accepted Points)"
    },

    constructor: function(config) {
        this.initConfig(config);
        this.callParent(arguments);
    },
    runCalculation: function (snapshots) {
        var calculatorConfig = this._prepareCalculatorConfig(),
            seriesConfig = this._buildSeriesConfig(calculatorConfig);

        var calculator = this.prepareCalculator(calculatorConfig);
        calculator.addSnapshots(snapshots, this._getStartDate(snapshots), this._getEndDate(snapshots));

        this.snapshots = snapshots;

        return this._transformLumenizeDataToHighchartsSeries(calculator, seriesConfig);
    },
    _getTypes: function(){
        var typeHierarchy = [];
        if (this.showStories){
            typeHierarchy.push('HierarchicalRequirement');
        }
        if (this.showDefects){
            typeHierarchy.push('Defect');
        }
        return typeHierarchy;
    },
    getDerivedFieldsOnInput: function() {
        var completedScheduleStateNames = this.getCompletedScheduleStateNames(),
            usePoints = this.usePoints;

        var fields = [
            {
                "as": "Planned",
                "f": function(snapshot) {
                    if (snapshot.ScheduleState){ //We've added this to weed out the portfolio items for the count
                        if (usePoints){
                            return snapshot.PlanEstimate || 0;
                        } else {
                            return 1;
                        }
                    }
                    return 0;
                }
            }];

        var typeHierarchy = this._getTypes();

        Ext.Array.each(completedScheduleStateNames, function(ss){
            Ext.Array.each(typeHierarchy, function(t){
                fields.push({
                    "as": ss + t,
                    "f": function(snapshot) {
                        if (Ext.Array.contains(snapshot._TypeHierarchy, t) && snapshot.ScheduleState === ss) {
                            if (usePoints){
                                return snapshot.PlanEstimate || 0;
                            } else {
                                return 1;
                            }
                        }
                        return 0;
                    }
                });
            });
        });

        return fields;
    },
    getMetrics: function() {
        var completedScheduleStateNames = this.getCompletedScheduleStateNames(),
            metrics = [],
            typeHierarchy = this._getTypes();

        Ext.Array.each(completedScheduleStateNames, function(ss){
            Ext.Array.each(typeHierarchy, function(t){
                metrics.push({
                    "field": ss+t,
                    "f": "sum"
                });
            });
        });

        metrics = metrics.concat([{
            "field": "Planned",
            "f": "sum"
        }]);

        return metrics;
    },
    _getSummedData: function(seriesData, metricNames, types){
        if (!Ext.isArray(metricNames)){
            metricNames = [metricNames];
        }
        types = types || [];

        var sum_xy = 0;
        var sum_x = 0;
        var sum_y = 0;
        var sum_x_squared = 0;
        var n = 0;
        var current_date = new Date();

        for (var i=0; i<seriesData.length; i++){
            var val = 0;

            Ext.Array.each(metricNames, function(m){
                if (types.length > 0){
                    Ext.Array.each(types, function(t){

                        val += (seriesData[i][m + t + "_sum"] || 0);
                    });
                } else {
                    val += (seriesData[i][m + "_sum"] || 0);
                }

            });

            if (val){
                sum_xy += val * i;
                sum_x += i;
                sum_y += val;
                sum_x_squared += i * i;
                n++;
            }

            if (i + 1 < seriesData.length){
                var point_date = Rally.util.DateTime.fromIsoString(seriesData[i+1].tick);
                if (point_date > current_date) {
                    i = seriesData.length;
                }
            }
        }
        return {
            sumXY: sum_xy,
            sumX: sum_x,
            sumY: sum_y,
            sumXSquared: sum_x_squared,
            n: n
        };
    },
    _getSlope: function(summedData){
        if ((summedData.n * summedData.sumXSquared - summedData.sumX * summedData.sumX) !== 0){
            return (summedData.n*summedData.sumXY - summedData.sumX * summedData.sumY)/(summedData.n*summedData.sumXSquared - summedData.sumX * summedData.sumX);
        }
        return 0;
    },
    _getIntercept: function(summedData){
        var slope = this._getSlope(summedData);
        if (summedData.n === 0){
            return 0;
        }
        return (summedData.sumY - slope * summedData.sumX)/summedData.n;
    },
    getSummaryMetricsConfig: function () {
        var me = this,
            completedScheduleStates = this.completedScheduleStateNames,
            summaryMetrics = [],
            types = this._getTypes();

        if (this.showPlannedPredictionLine){
            summaryMetrics = summaryMetrics.concat({
                "as": "planned_slope",
                "f": function(seriesData, metrics) {
                    var summedData = me._getSummedData(seriesData, "Planned");
                    return me._getSlope(summedData);
                }
            },{
                "as": "planned_intercept",
                "f": function(seriesData, metrics) {
                    var summedData = me._getSummedData(seriesData, "Planned");
                    return me._getIntercept(summedData);
                }
            });
        }

        if (this.showAcceptedPredictionLine){
            summaryMetrics = summaryMetrics.concat({
                "as": "accepted_slope",
                "f": function(seriesData, metrics) {
                    var summedData = me._getSummedData(seriesData, completedScheduleStates, types);
                    return me._getSlope(summedData);
                }
            },{
                "as": "accepted_intercept",
                "f": function(seriesData, metrics) {
                    var summedData = me._getSummedData(seriesData, completedScheduleStates, types);
                    return me._getIntercept(summedData);
                }
            });
        }
        return summaryMetrics;
    },
    getDerivedFieldsAfterSummary: function () {

        var metrics = [],
            completedScheduleStateNames = this.getCompletedScheduleStateNames(),
            typeHierarchy = this._getTypes();

        var now = new Date(),
            endOfDayToday = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23,59,59,999);

        Ext.Array.each(completedScheduleStateNames, function(ss){
            Ext.Array.each(typeHierarchy, function(t){
                var fieldDisplayName = Ext.String.format("{0} ({1})",ss,t.replace('HierarchicalRequirement','User Story'));
                metrics.push({
                    "as": fieldDisplayName,
                    "f": function(snapshot, index, metrics, seriesData){
                        var point_date = Rally.util.DateTime.fromIsoString(snapshot.tick);
                       // console.log('point_date', point_date, endOfDayToday)
                        if (point_date > endOfDayToday){
                            return null;
                        }
                        return snapshot[ss + t + "_sum"];
                    },
                    "display": "column"
                });
            });
        });

        if (this.showPlannedPredictionLine){
            metrics.push({
                "as": "Planned",
                "f": function(snapshot, index, metrics, seriesData){
                    var point_date = Rally.util.DateTime.fromIsoString(snapshot.tick);
                    if (point_date > new Date()){
                        return null;
                    }
                    return snapshot.Planned_sum;
                },
                "display": "line"
            });

           metrics.push({
               "as": this.plannedPredictionLineName ,
               "f": function(snapshot, index, metrics, seriesData) {
                   return Math.round(metrics.planned_intercept + metrics.planned_slope * index);
               },
               "display": "line",
               "dashStyle": "ShortDash"
           });
        } else {
            metrics.push({
                "as": "Planned",
                "f": function(snapshot, index, metrics, seriesData){
                    return snapshot.Planned_sum;
                },
                "display": "line"
            });
        }

        if (this.showAcceptedPredictionLine){
            metrics.push({
                "as": this.acceptedPredictionLineName,
                "f": function(snapshot, index, metrics, seriesData) {
                    return Math.round(metrics.accepted_intercept + metrics.accepted_slope * index);
                },
                "display": "line",
                "dashStyle": "ShortDash"
            });
        }

        return metrics;
    },
    prepareChartData: function (stores) {
        var snapshots = [], ids = [];

        Ext.Array.each(stores, function (store) {
            store.each(function(record){
                var data = record.raw;
                //We need to make sure the snapshots are unique so we are filtering them here.
                //The alternative is making a single store config that can filter both.
                //This approach may not be faster, but it makes the configuration code easier to read.
                if (!Ext.Array.contains(ids, data._id)){
                    ids.push(data._id);
                    snapshots.push(data);
                }
            });
        });
        return this.runCalculation(snapshots);
    },
    _buildSeriesConfig: function (calculatorConfig) {
        var aggregationConfig = [],
            derivedFieldsAfterSummary = calculatorConfig.deriveFieldsAfterSummary;

        for (var j = 0, jlength = derivedFieldsAfterSummary.length; j < jlength; j += 1) {
            var derivedField = derivedFieldsAfterSummary[j];
            aggregationConfig.push({
                name: derivedField.as,
                type: derivedField.display,
                dashStyle: derivedField.dashStyle || "Solid"
            });
        }

        return aggregationConfig;
    }
});

Ext.define('Rally.technicalservices.Toolbox',{
    singleton: true,

    fetchData: function(config){
        var deferred = Ext.create('Deft.Deferred');

        config.limit = Infinity;
        Ext.create('Rally.data.wsapi.Store',config).load({
            callback: function(records, operation){
                if (operation.wasSuccessful()){
                    deferred.resolve(records);
                } else {
                    deferred.reject(operation);
                }
            }
        });
        return deferred;
    },

    fetchPortfolioItemTypes: function(){
        var deferred = Ext.create('Deft.Deferred');

        var typeStore = Ext.create('Rally.data.wsapi.Store', {
            autoLoad: false,
            model: 'TypeDefinition',
            sorters: [{
                property: 'Ordinal',
                direction: 'ASC'
            }],
            filters: [{
                property: 'Parent.Name',
                operator: '=',
                value: 'Portfolio Item'
            }, {
                property: 'Creatable',
                operator: '=',
                value: true
            }]
        });

        typeStore.load({
            scope: this,
            callback: function (records, operation, success) {
                console.log('callback', operation, success);
                if (success){
                    deferred.resolve(records);

                } else {
                    deferred.reject("Error loading Portfolio Item Types:  " + operation.error.errors.join(','));
                }
            }
        });
        return deferred;
    },

    fetchScheduleStates: function(){
        var deferred = Ext.create('Deft.Deferred');
        Rally.data.ModelFactory.getModel({
            type: 'HierarchicalRequirement',
            success: function(model) {
                var field = model.getField('ScheduleState');
                field.getAllowedValueStore().load({
                    callback: function(records, operation, success) {
                        if (success){
                            var values = [];
                            for (var i=0; i < records.length ; i++){
                                values.push(records[i].get('StringValue'));
                            }
                            deferred.resolve(values);
                        } else {
                            deferred.reject('Error loading ScheduleState values for User Story:  ' + operation.error.errors.join(','));
                        }
                    },
                    scope: this
                });
            },
            failure: function() {
                var error = "Could not load schedule states";
                deferred.reject(error);
            }
        });
        return deferred.promise;
    },

    fetchPreliminaryEstimateValues: function(){
        return this.fetchData({
            model: 'PreliminaryEstimate',
            fetch: ['ObjectID','Name','Value']
        });
    }
});

Ext.override(Rally.sdk.Bootstrapper,{
    _isExternal: function() {
        return this.app.isExternal();
        //return !!Rally.environment.externalContext;
    }
});
Ext.define("release-burnup", {
    extend: 'Rally.app.App',
    componentCls: 'app',
    logger: new Rally.technicalservices.Logger(),
    defaults: { margin: 10 },
    items: [
        {xtype:'container',itemId:'headerBox', layout: 'hbox'},
        {xtype:'container',itemId:'displayBox'}
    ],

    integrationHeaders : {
        name : "ts-release-burnup"
    },

    config: {
        defaultSettings: {
            showPlannedPredictionLine: false,
            showAcceptedPredictionLine: true,
            showDefects: true,
            showStories: true,
            showExportButton: false
        }
    },

    chartUnits: ['Points','Count'],  //Default is first in the list
    portfolioItemTypes: ['PortfolioItem/Feature'],
    completedStates: ['Accepted', 'Released'],
    preliminaryEstimateValueHashByObjectID: {},

    timeboxStartDateField: 'ReleaseStartDate',
    timeboxEndDateField: 'ReleaseDate',
    timeboxType: 'release',
    timeboxTypePicker: 'rallyreleasecombobox',

    launch: function() {

        Deft.Promise.all([
            Rally.technicalservices.Toolbox.fetchPortfolioItemTypes(),
            Rally.technicalservices.Toolbox.fetchScheduleStates()
        //    Rally.technicalservices.Toolbox.fetchPreliminaryEstimateValues()
        ]).then({
            success: this._initializeApp,
            failure: this._showError,
            scope: this
        });



    },
    _initializeApp: function(results){
        this.portfolioItemTypes = _.map(results[0], function(r){ return r.get('TypePath'); });
        this.completedStates = results[1].slice(_.indexOf(results[1],"Accepted"));
        this.preliminaryEstimateValueHashByObjectID = _.reduce(results[2],function(hash, record){
            hash[record.get('ObjectID')] = record.get('Value');
            return hash;
        },{});
        this.logger.log('_initializeApp', this.portfolioItemTypes, this.completedStates, this.preliminaryEstimateValueHashByObjectID);

        this._addComponents();
    },
    isOnScopedDashboard: function(){
        if (this.getContext().getTimeboxScope() && this.getContext().getTimeboxScope().type === this.timeboxType){
            return true;
        }
        return false;
    },
    _addComponents: function(){
        var headerBox = this.down('#headerBox');
        headerBox.removeAll();
        if (!this.isOnScopedDashboard()){
            var rcb = headerBox.add({
                xtype: this.timeboxTypePicker
            });
            rcb.on('select', this.updateTimebox, this);
            rcb.on('ready', this.updateTimebox, this);
        }
        var cb = headerBox.add({
            xtype: 'tscustomcombobox',
            itemId: 'cbUnit',
            allowedValues: this.chartUnits
        });
        cb.on('select',this._updateBurnup, this);
        if (this.isOnScopedDashboard()){
            this.updateTimebox();
        }

        if (this.getShowExport()){
            var btn = headerBox.add({
                xtype: 'rallybutton',
                iconCls: 'icon-export secondary rly-small',
                margin: '0 0 0 25'
            });
            btn.on('click', this._export, this);
        }

        headerBox.add({
            xtype: 'container',
            itemId: 'etlDate',
            padding: 10,
            tpl: '<tpl><div class="etlDate">Data current as of {etlDate}</div></tpl>'
        });
    },
    _export: function(){
        var chart = this.down('rallychart'),
            snapshots = chart && chart.calculator && chart.calculator.snapshots,
            chartEndDate = chart.calculator.endDate,
            chartStartDate = chart.calculator.startDate;
        this.logger.log('_Export', chart.calculator ,chartStartDate, chartEndDate);
        if (snapshots){
            var csv = [];
            var headers = ['FormattedID','PlanEstimate','ScheduleState','_ValidFrom','_ValidTo'];
            csv.push(headers.join(','));
            Ext.Array.each(snapshots, function(s){
                var validFrom = Rally.util.DateTime.fromIsoString(s._ValidFrom),
                    validTo = Rally.util.DateTime.fromIsoString(s._ValidTo);

                if (validFrom < chartEndDate && validTo >= chartStartDate){
                    var row = [s.FormattedID, s.PlanEstimate, s.ScheduleState, s._ValidFrom, s._ValidTo];
                    csv.push(row.join(','));
                }
            });
            csv = csv.join("\r\n");

            CArABU.technicalservices.Exporter.saveCSVToFile(csv, Ext.String.format('export-{0}.csv', Rally.util.DateTime.format(new Date(), 'Y-m-d')));
        }
    },
    _updateETLDate: function(store, records, success){
        this.logger.log('_updateETLDate', store, records, success);
        var etlDate = store && store.proxy && store.proxy._etlDate;
        if (etlDate){
            this.down('#etlDate').update({etlDate: Rally.util.DateTime.fromIsoString(etlDate)});
        }
    },
    getUnit: function(){
        return this.down('#cbUnit') && this.down('#cbUnit').getValue() || this.chartUnits[0];
    },
    getTimeboxStartDate: function(){
        var record = this.getTimeboxRecord();
        return record.get(this.timeboxStartDateField);
    },
    getTimeboxEndDate: function(){
        var record = this.getTimeboxRecord();
        return record.get(this.timeboxEndDateField);
    },
    getTimeboxRecord: function(){
        var record = null;
        this.logger.log('getTimeboxRecord', this.isOnScopedDashboard(), this.down(this.timeboxTypePicker) && this.down(this.timeboxTypePicker).getRecord())
        if (this.isOnScopedDashboard()){
            record = this.getContext().getTimeboxScope().getRecord();
        } else {
            record = this.down(this.timeboxTypePicker) && this.down(this.timeboxTypePicker).getRecord();
        }
        return record;
    },
    getTimeboxFilter: function(isForTimebox){
        var record = this.getTimeboxRecord();

        var prefix = isForTimebox ? "" : Ext.String.capitalize(this.timeboxType) + ".";

        if (record){
            return Rally.data.wsapi.Filter.and([
                {
                    property: prefix + 'Name',
                    value: record.get('Name')
                },
                {
                    property: prefix + this.timeboxStartDateField,
                    value: Rally.util.DateTime.toUtcIsoString(this.getTimeboxStartDate())
                },
                {
                    property: prefix + this.timeboxEndDateField,
                    value: Rally.util.DateTime.toUtcIsoString(this.getTimeboxEndDate())
                }
            ]);
        }
        return [];
    },
    updateTimebox: function(){
        var timeboxFilter = this.getTimeboxFilter();
        this.logger.log('updateTimebox', timeboxFilter.toString());

        this.releases = [];
        this.portfolioItems = [];

        if (!timeboxFilter || timeboxFilter.length === 0){
            this._showMissingCriteria();
            return;
        }
        this.setLoading(true);
        var promises = [Rally.technicalservices.Toolbox.fetchData({
            model: Ext.String.capitalize(this.timeboxType),
            fetch: ['ObjectID'],
            filters: this.getTimeboxFilter(true)
        }), Rally.technicalservices.Toolbox.fetchData({
            model: this.portfolioItemTypes[0],
            fetch: ['ObjectID','PreliminaryEstimate','Value'],
            context: {project: null},
            filters: timeboxFilter
        })];

        var me = this;
        Deft.Promise.all(promises).then({

            success: function(results){
                this.logger.log('updateTimebox Results', results);
                this.timeboxes = results[0];
                this.portfolioItems = results[1];
                this._updateBurnup();
            },
            failure: this._showError,
            scope: this
        }).always(function(){
            me.setLoading(false);
        });
    },
    onTimeboxScopeChange: function(timeboxScope){
        this.logger.log('onTimeboxScopeChange',timeboxScope);
        if (timeboxScope && timeboxScope.type === this.timeboxType){
            this.getContext().setTimeboxScope(timeboxScope);
            this.updateTimebox();
        }
    },
    _getFieldValueArray: function(records, fieldName){
        return _.map(records || [], function(r){ return r.get(fieldName); });
    },
    _showMissingCriteria: function(){
        this.down('#displayBox').removeAll();
        this.down('#displayBox').add({
            xtype: 'container',
            html: 'Please select a release filter.'
        });
    },
    _showError: function(msg){
        Rally.ui.notify.Notifier.showError({message: msg});
    },
    _getChartColors: function(){
        //In order to keep the colors consistent for the different options,
        //we need to build the colors according to the settings
        var chartColors = [],
            numCompletedStates = this.completedStates.length;

        if (this.getShowStories()){
            chartColors.push('#8DC63F');
        }
        if (this.getShowDefects()){
            chartColors.push('#FBB990');
        }
        if (numCompletedStates > 1){
            if (this.getShowStories()){
                chartColors.push('#1E7C00');
            }
            if (this.getShowDefects()){
                chartColors.push('#FF8200');
            }
        }
        chartColors.push('#7CAFD7');
        if (this.getShowPlannedPredictionLine()){
            chartColors.push('#666');
        }
        if (this.getShowAcceptedPredictionLine()){
            chartColors.push('#005EB8');
        }
        return chartColors;
    },
    _updateBurnup: function(){
        this.logger.log('_updateBurnup', this.getUnit(), this.getTimeboxEndDate());

        this.down('#displayBox').removeAll();

        if (!this.timeboxes || this.timeboxes.length === 0){
            this._showMissingCriteria();
            return;
        }

        this.down('#displayBox').add({
            xtype: 'rallychart',
            chartColors: this._getChartColors(),
            storeType: 'Rally.data.lookback.SnapshotStore',
            storeConfig: this._getStoreConfig(),
            calculatorType: 'Rally.technicalservices.ReleaseBurnupCalculator',
            calculatorConfig: {
                usePoints: this.getUnit() === 'Points',
                completedScheduleStateNames: this.completedStates,
                startDate: this.getTimeboxStartDate(),
                endDate: this.getTimeboxEndDate(),
                showPlannedPredictionLine: this.getShowPlannedPredictionLine(),
                showAcceptedPredictionLine: this.getShowAcceptedPredictionLine(),
                showDefects: this.getShowDefects(),
                showStories: this.getShowStories()
                //preliminaryEstimateValueHashByObjectID: this.preliminaryEstimateValueHashByObjectID
            },
            chartConfig: this._getChartConfig()
        });
    },
    getBooleanSetting: function(settingName){
        return this.getSetting(settingName) === 'true' || this.getSetting(settingName) === true;
    },
    getShowPlannedPredictionLine: function(){
        return this.getBooleanSetting('showPlannedPredictionLine');
    },
    getShowAcceptedPredictionLine: function(){
        return this.getBooleanSetting('showAcceptedPredictionLine');
    },
    getShowDefects: function(){
        return this.getBooleanSetting('showDefects');
    },
    getShowExport: function(){
        return this.getBooleanSetting('showExportButton');
    },
    getShowStories: function(){
        var showStories = this.getBooleanSetting('showStories');
        if (!this.getShowDefects()){
            return true;
        }
        return showStories;

    },
    _getStoreConfig: function(){

        var rOids = this._getFieldValueArray(this.timeboxes,'ObjectID'),
            piOids = this._getFieldValueArray(this.portfolioItems,'ObjectID'),
            projectOid = this.getContext().getProject().ObjectID;
        this.logger.log('_getStoreConfig', this.portfolioItems);
        var typeHierarchy = [];
        if (this.getShowStories()){
            typeHierarchy.push('HierarchicalRequirement');
        }
        if (this.getShowDefects()){
            typeHierarchy.push('Defect');
        }
        if (typeHierarchy.length === 0){
            typeHierarchy = ['HierarchicalRequirement'];
        }

        var configs = [{
            find: {
                _TypeHierarchy: {$in: typeHierarchy},
                Children: null,
                Release: {$in: rOids} //We don't need project hierarchy here because the releases are associated with the current project hierarchy.
            },
            fetch: ['ScheduleState', 'PlanEstimate','_id','_TypeHierarchy','FormattedID'],
            hydrate: ['ScheduleState','_TypeHierarchy'],
            removeUnauthorizedSnapshots: true,
            sort: {
                _ValidFrom: 1
            },
            context: this.getContext().getDataContext(),
            limit: Infinity,
            listeners: {
                load: this._updateETLDate,
                scope: this
            }
        }];

        piOids = piOids.slice(-10);
        this.logger.log('PortfolioItems', piOids.length);
        if (piOids && piOids.length > 0){


            configs.push({
                find: {
                        _TypeHierarchy: {$in: typeHierarchy},
                        Children: null,
                        _ItemHierarchy: {$in: piOids},
                        _ProjectHierarchy: projectOid // We need project hierarchy here to limit the stories and defects to just those in this project.
                },
                fetch: ['ScheduleState', 'PlanEstimate','_id','_TypeHierarchy','FormattedID'],
                hydrate: ['ScheduleState','_TypeHierarchy'],
                compress: true,
                removeUnauthorizedSnapshots: true,
                sort: {
                    _ValidFrom: 1
                },
                //context: this.getContext().getDataContext(),
                limit: Infinity,
                listeners: {
                    load: this._updateETLDate,
                    scope: this
                }
            });
        }
        return configs;
    },
    _getChartConfig: function(){
        var numTicks = 6;
        return {
            chart: {
                defaultSeriesType: 'area',
                zoomType: 'xy'
            },
            title: {
                text: this.getTimeboxRecord() && this.getTimeboxRecord().get('Name') || "No Release",
                style: {
                    color: '#666',
                    fontSize: '18px',
                    fontFamily: 'ProximaNova',
                    fill: '#666'
                }
            },
            xAxis: {
                categories: [],
                tickmarkPlacement: 'on',
                title: {
                    text: 'Date',
                    margin: 10,
                    style: {
                        color: '#444',
                        fontFamily:'ProximaNova',
                        textTransform: 'uppercase',
                        fill:'#444'
                    }
                },
                labels: {
                    style: {
                        color: '#444',
                        fontFamily:'ProximaNova',
                        textTransform: 'uppercase',
                        fill:'#444'
                    },
                    formatter: function(){
                        var d = new Date(this.value);
                        return Rally.util.DateTime.format(d, 'm/d/Y');
                    }
                },
                tickPositioner: function () {
                    var positions = [],
                        tick = Math.floor(this.dataMin),
                        increment = Math.ceil((this.dataMax - this.dataMin) / numTicks);

                    if (this.dataMax !== null && this.dataMin !== null) {
                        for (tick; tick - increment <= this.dataMax; tick += increment) {
                            positions.push(tick);
                        }
                    }
                    return positions;
                }
            },
            yAxis: [
                {
                    title: {
                        text: this.getUnit(),
                        style: {
                            color: '#444',
                            fontFamily:'ProximaNova',
                            textTransform: 'uppercase',
                            fill:'#444'
                        }
                    },
                    labels: {
                        style: {
                            color: '#444',
                            fontFamily:'ProximaNova',
                            textTransform: 'uppercase',
                            fill:'#444'
                        }
                    },
                    min: 0
                }
            ],
            legend: {
                itemStyle: {
                        color: '#444',
                        fontFamily:'ProximaNova',
                        textTransform: 'uppercase'
                },
                borderWidth: 0
            },
            tooltip: {
                backgroundColor: '#444',
                headerFormat: '<span style="display:block;margin:0;padding:0 0 2px 0;text-align:center"><b style="font-family:NotoSansBold;color:white;">{point.key}</b></span><table><tbody>',
                footerFormat: '</tbody></table>',
                pointFormat: '<tr><td class="tooltip-label"><span style="color:{series.color};width=100px;">\u25CF</span> {series.name}</td><td class="tooltip-point">{point.y}</td></tr>',
                shared: true,
                useHTML: true,
                borderColor: '#444'
            },
            plotOptions: {
                series: {
                    marker: {
                        enabled: false,
                        states: {
                            hover: {
                                enabled: true
                            }
                        }
                    },
                    groupPadding: 0.01
                },
                column: {
                    stacking: true,
                    shadow: false
                }
            }
        };
    },
    getOptions: function() {
        return [
            {
                text: 'About...',
                handler: this._launchInfo,
                scope: this
            }
        ];
    },
    getSettingsFields: function(){
        var labelWidth = 200;

        return [{
            xtype: 'rallycheckboxfield',
            fieldLabel: 'Show Planned Prediction Line',
            labelAlign: 'right',
            labelWidth: labelWidth,
            name: 'showPlannedPredictionLine'
        },{
            xtype: 'rallycheckboxfield',
            fieldLabel: 'Show Accepted Prediction Line',
            labelAlign: 'right',
            labelWidth: labelWidth,
            name: 'showAcceptedPredictionLine'
        },{
            xtype: 'rallycheckboxfield',
            fieldLabel: 'Show Defects',
            labelAlign: 'right',
            labelWidth: labelWidth,
            name: 'showDefects'
        },{
            xtype: 'rallycheckboxfield',
            fieldLabel: 'Show User Stories',
            labelAlign: 'right',
            labelWidth: labelWidth,
            name: 'showStories'
        },{
            xtype: 'rallycheckboxfield',
            fieldLabel: 'Show Export Button',
            labelAlign: 'right',
            labelWidth: labelWidth,
            name: 'showExportButton'

        }];
    },
    _launchInfo: function() {
        if ( this.about_dialog ) { this.about_dialog.destroy(); }
        this.about_dialog = Ext.create('Rally.technicalservices.InfoLink',{});
    },
    
    isExternal: function(){
        return typeof(this.getAppId()) == 'undefined';
    },
    
    //onSettingsUpdate:  Override
    onSettingsUpdate: function (settings){
        this.logger.log('onSettingsUpdate',settings);
        // Ext.apply(this, settings);
        this.launch();
    }
});

            
               Rally.launchApp('release-burnup', {
                   name: 'Release Burnup'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}
.highcharts-tooltip {
    font-family:NotoSansBold;
    color:white;
}
.tooltip-point {
    text-align: right;
    color: white;
}
.tooltip-label {
    font-family:NotoSans;
    white-space:nowrap;
    font-size:13px;
    color:white;
}
.etlDate {
    color: grey;
    font-family:NotoSans;
    font-style: italic;
}
    </style>

</head>
<body></body>
</html>