<!DOCTYPE html>
<html>
<head>
    <title>Release Burnup</title>
    <!--  (c) 2016 CA Technologies.  All Rights Reserved. -->
    <!--  Build Date: Tue May 03 2016 18:08:38 GMT-0600 (MDT) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Tue May 03 2016 18:08:38 GMT-0600 (MDT)";
        var BUILDER = "kcorkan";
        var CHECKSUM = 18647225553;
    </script>
    
    <script type="text/javascript" src="/apps/2.1/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Rally.ui.dialog.Dialog',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
    title: "Build Information",
    
    defaults: { padding: 5, margin: 5 },

    closable: true,
     
    draggable: true,

    autoShow: true,
   
    width: 350,
    
    informationalConfig: null,
    
    items: [{xtype:'container', itemId:'information' }],
    
    initComponent: function() {
        var id = Ext.id(this);
        this.title =  "<span class='icon-help'> </span>" + this.title;
        this.callParent(arguments);
    },
    
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        string = string.replace(/var BUILDER = .*;/,"");
        string = string.replace(/\s/g,"");  //Remove all whitespace from the string.
       
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
   
        return chk;
    },
    
    _checkChecksum: function(container) {
        var deferred = Ext.create('Deft.Deferred');
        var me = this;
        
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    var stored_checksum = me._generateChecksum(text);
                    if ( CHECKSUM !== stored_checksum ) {
                        deferred.resolve(false);
                        return;
                    }
                }
                deferred.resolve(true);
            }
        });
        
        return deferred.promise;
    },
    
    _addToContainer: function(container){
        var config = Ext.apply({
            xtype:'container',
            height: 200,
            overflowY: true
        }, this.informationalConfig);
        
        container.add(config);
    },
    
    afterRender: function() {
        var app = Rally.getApp();
        
        if ( !Ext.isEmpty( this.informationalConfig ) ) {
            var container = this.down('#information');
            this._addToContainer(container);
            
        }
        
        if (! app.isExternal() ) {
            this._checkChecksum(app).then({
                scope: this,
                success: function(result){
                    if ( !result ) {
                        this.addDocked({
                            xtype:'container',
                            cls: 'build-info',
                            dock: 'bottom',
                            padding: 2,
                            html:'<span class="icon-warning"> </span>Checksums do not match'
                        });
                    }
                },
                failure: function(msg){
                    console.log("oops:",msg);
                }
            });
        } else {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                dock: 'bottom',
                html:'... Running externally'
            });
        }
        this.callParent(arguments);
    },
    
    beforeRender: function() {
        var me = this;
        this.callParent(arguments);

        if (this.informationHtml) {
            this.addDocked({
                xtype: 'component',
                componentCls: 'intro-panel',
                padding: 2,
                html: this.informationHtml,
                doc: 'top'
            });
        }
        
        this.addDocked({
            xtype:'container',
            cls: 'build-info',
            padding: 2,
            dock:'bottom',
            html:"This app was created by the CA AC Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            this.addDocked({
                xtype:'container',
                cls: 'build-info',
                padding: 2,
                dock: 'bottom',
                html: Ext.String.format("Build date/time: {0} ({1})",
                    APP_BUILD_DATE,
                    BUILDER)
            });
        }
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

Ext.define('Rally.technicalservices.CustomStoreDropdown',{
    extend: 'Rally.ui.combobox.ComboBox',
    alias: 'widget.tscustomcombobox',

    constructor: function(config) {
        if (!config.valueField){
            config.valueField = 'value';
        }
        if (!config.displayField){
            config.displayField = config.valueField;
        }

        var storeData = config.allowedValues || [];
        if (storeData.length > 0 && Ext.isString(storeData[0])){
            storeData = _.map(storeData, function(item){
                var obj = {};
                obj[config.valueField] = item;
                return obj;
            });
        }
        console.log ('cfg',config, storeData);
        config.store = Ext.create('Ext.data.Store', {
            fields: [config.valueField],
            data: storeData
        });
        console.log ('cfg',config);
        return this.callParent([config]);
    }
});

Ext.define('Rally.technicalservices.ReleaseBurnupCalculator',{
    extend: 'Rally.data.lookback.calculator.TimeSeriesCalculator',
    config: {
        completedScheduleStateNames: ['Accepted'],
        usePoints: true
    },

    constructor: function(config) {
        this.initConfig(config);
        this.callParent(arguments);
    },

    getDerivedFieldsOnInput: function() {
        var completedScheduleStateNames = this.getCompletedScheduleStateNames(),
            usePoints = this.usePoints;
            //preliminaryEstimateValues = this.preliminaryEstimateValueHashByObjectID;

        var fields = [
            {
            //   "as": "PreliminaryEstimate",
            //    "f": function(snapshot){
            //        if (snapshot.PreliminaryEstimate){
            //            return preliminaryEstimateValues[snapshot.PreliminaryEstimate] || 0;
            //        }
            //        return 0;
            //    }
            //},{
                "as": "Planned",
                "f": function(snapshot) {
                    if (snapshot.ScheduleState){ //We've added this to weed out the portfolio items for the count
                        if (usePoints){
                            return snapshot.PlanEstimate || 0;
                        } else {
                            return 1;
                        }
                    }
                    return 0;
                }
            }];

        Ext.Array.each(completedScheduleStateNames, function(ss){
            fields.push({
                "as": ss,
                "f": function(snapshot) {
                    if (snapshot.ScheduleState === ss) {
                        if (usePoints){
                            return snapshot.PlanEstimate || 0;
                        } else {
                            return 1;
                        }
                    }
                    return 0;
                }
            });
        });

        return fields;
    },

    getMetrics: function() {
        var completedScheduleStateNames = this.getCompletedScheduleStateNames(),
            metrics = [];

        Ext.Array.each(completedScheduleStateNames, function(ss){
            metrics.push({
                "field": ss,
                "as": ss,
                "f": "sum",
                "display": "column"
            });
        });

        metrics = metrics.concat([{
            "field": "Planned",
            "as": "Planned",
            "display": "line",
            "f": "sum"
        //},{
        //    "field": "PreliminaryEstimate",
        //    "as": "PreliminaryEstimate",
        //    "display": "line",
        //    "f": "sum"
        }]);

        return metrics;
    },
    _getSummedData: function(seriesData, metricNames){

        if (!Ext.isArray(metricNames)){
            metricNames = [metricNames];
        }

        var sum_xy = 0;
        var sum_x = 0;
        var sum_y = 0;
        var sum_x_squared = 0;
        var n = 0;
        for (var i=0; i<seriesData.length; i++){
            var val = 0;
            Ext.Array.each(metricNames, function(m){
                val += (seriesData[i][m] || 0);
            });

            if (val){
                sum_xy += val * i;
                sum_x += i;
                sum_y += val;
                sum_x_squared += i * i;
                n++;
            }
        }
        return {
            sumXY: sum_xy,
            sumX: sum_x,
            sumY: sum_y,
            sumXSquared: sum_x_squared,
            n: n
        };
    },
    _getSlope: function(summedData){

        if ((summedData.n * summedData.sumXSquared - summedData.sumX * summedData.sumX) !== 0){
            return (summedData.n*summedData.sumXY - summedData.sumX * summedData.sumY)/(summedData.n*summedData.sumXSquared - summedData.sumX * summedData.sumX);
        }
        return 0;
    },
    _getIntercept: function(summedData){
        var slope = this._getSlope(summedData);
        if (summedData.n === 0){
            return 0;
        }

        return (summedData.sumY - slope * summedData.sumX)/summedData.n;
    },
    getSummaryMetricsConfig: function () {
        var me = this,
            completedScheduleStates = this.completedScheduleStateNames;
        if (!this.showPredictionLines){
            return [];
        }

        return [{
            "as": "planned_slope",
            "f": function(seriesData, metrics) {
              var summedData = me._getSummedData(seriesData, "Planned");
              return me._getSlope(summedData);
            }
        },{
            "as": "planned_intercept",
            "f": function(seriesData, metrics) {
                var summedData = me._getSummedData(seriesData, "Planned");
                return me._getIntercept(summedData);
            }
        },{
            "as": "accepted_slope",
            "f": function(seriesData, metrics) {
                var summedData = me._getSummedData(seriesData, completedScheduleStates);
                return me._getSlope(summedData);
            }
        },{
            "as": "accepted_intercept",
            "f": function(seriesData, metrics) {
                var summedData = me._getSummedData(seriesData, completedScheduleStates);
                return me._getIntercept(summedData);
            }
        }];
    },
    getDerivedFieldsAfterSummary: function () {

        if (!this.showPredictionLines){
            return [];
        }

        return [{
                 "as": "Prediction (Planned Points)",
                 "f": function(snapshot, index, metrics, seriesData) {
                      return Math.round(metrics.planned_intercept + metrics.planned_slope * index);

                  },
                  "display": "line",
                  "dashStyle": "ShortDash"
             },{
            "as": "Prediction (Accepted Points)",
            "f": function(snapshot, index, metrics, seriesData) {
                return Math.round(metrics.accepted_intercept + metrics.accepted_slope * index);

            },
            "display": "line",
            "dashStyle": "ShortDash"
        }];
    },
    prepareChartData: function (stores) {
        var snapshots = [], ids = [];

        Ext.Array.each(stores, function (store) {
            store.each(function(record){
                var data = record.raw;
                //We need to make sure the snapshots are unique so we are filtering them here.
                //The alternative is making a single store config that can filter both.
                //This approach may not be faster, but it makes the configuration code easier to read.
                if (!Ext.Array.contains(ids, data._id)){
                    ids.push(data._id);
                    snapshots.push(data);
                }
            });
        });
        return this.runCalculation(snapshots);
    }
});

Ext.define('Rally.technicalservices.Toolbox',{
    singleton: true,

    fetchData: function(config){
        var deferred = Ext.create('Deft.Deferred');

        config.limit = Infinity;
        Ext.create('Rally.data.wsapi.Store',config).load({
            callback: function(records, operation){
                if (operation.wasSuccessful()){
                    deferred.resolve(records);
                } else {
                    deferred.reject(operation);
                }
            }
        });
        return deferred;
    },

    fetchPortfolioItemTypes: function(){
        var deferred = Ext.create('Deft.Deferred');

        var typeStore = Ext.create('Rally.data.wsapi.Store', {
            autoLoad: false,
            model: 'TypeDefinition',
            sorters: [{
                property: 'Ordinal',
                direction: 'ASC'
            }],
            filters: [{
                property: 'Parent.Name',
                operator: '=',
                value: 'Portfolio Item'
            }, {
                property: 'Creatable',
                operator: '=',
                value: true
            }]
        });

        typeStore.load({
            scope: this,
            callback: function (records, operation, success) {
                console.log('callback', operation, success);
                if (success){
                    deferred.resolve(records);

                } else {
                    deferred.reject("Error loading Portfolio Item Types:  " + operation.error.errors.join(','));
                }
            }
        });
        return deferred;
    },

    fetchScheduleStates: function(){
        var deferred = Ext.create('Deft.Deferred');
        Rally.data.ModelFactory.getModel({
            type: 'HierarchicalRequirement',
            success: function(model) {
                var field = model.getField('ScheduleState');
                field.getAllowedValueStore().load({
                    callback: function(records, operation, success) {
                        if (success){
                            var values = [];
                            for (var i=0; i < records.length ; i++){
                                values.push(records[i].get('StringValue'));
                            }
                            deferred.resolve(values);
                        } else {
                            deferred.reject('Error loading ScheduleState values for User Story:  ' + operation.error.errors.join(','));
                        }
                    },
                    scope: this
                });
            },
            failure: function() {
                var error = "Could not load schedule states";
                deferred.reject(error);
            }
        });
        return deferred.promise;
    },

    fetchPreliminaryEstimateValues: function(){
        return this.fetchData({
            model: 'PreliminaryEstimate',
            fetch: ['ObjectID','Name','Value']
        });
    }
});
Ext.define("release-burnup", {
    extend: 'Rally.app.App',
    componentCls: 'app',
    logger: new Rally.technicalservices.Logger(),
    defaults: { margin: 10 },
    items: [
        {xtype:'container',itemId:'headerBox', layout: 'hbox'},
        {xtype:'container',itemId:'displayBox'}
    ],

    integrationHeaders : {
        name : "ts-release-burnup"
    },

    config: {
        defaultSettings: {
            showPredictionLines: false,
            showDefects: true,
            showStories: true
        }
    },

    chartUnits: ['Points','Count'],  //Default is first in the list
    portfolioItemTypes: ['PortfolioItem/Feature'],
    completedStates: ['Accepted', 'Released'],
    preliminaryEstimateValueHashByObjectID: {},

    timeboxStartDateField: 'ReleaseStartDate',
    timeboxEndDateField: 'ReleaseDate',
    timeboxType: 'release',
    timeboxTypePicker: 'rallyreleasecombobox',

    launch: function() {

        Deft.Promise.all([
            Rally.technicalservices.Toolbox.fetchPortfolioItemTypes(),
            Rally.technicalservices.Toolbox.fetchScheduleStates()
        //    Rally.technicalservices.Toolbox.fetchPreliminaryEstimateValues()
        ]).then({
            success: this._initializeApp,
            failure: this._showError,
            scope: this
        });

    },
    _initializeApp: function(results){
        this.portfolioItemTypes = _.map(results[0], function(r){ return r.get('TypePath'); });
        this.completedStates = results[1].slice(_.indexOf(results[1],"Accepted"));
        this.preliminaryEstimateValueHashByObjectID = _.reduce(results[2],function(hash, record){
            hash[record.get('ObjectID')] = record.get('Value');
            return hash;
        },{});
        this.logger.log('_initializeApp', this.portfolioItemTypes, this.completedStates, this.preliminaryEstimateValueHashByObjectID);

        this._addComponents();
    },
    isOnScopedDashboard: function(){
        if (this.getContext().getTimeboxScope() && this.getContext().getTimeboxScope().type === this.timeboxType){
            return true;
        }
        return false;
    },
    _addComponents: function(){
        var headerBox = this.down('#headerBox');
        headerBox.removeAll();
        if (!this.isOnScopedDashboard()){
            var rcb = headerBox.add({
                xtype: this.timeboxTypePicker
            });
            rcb.on('select', this.updateTimebox, this);
        }
        var cb = headerBox.add({
            xtype: 'tscustomcombobox',
            itemId: 'cbUnit',
            allowedValues: this.chartUnits
        });
        cb.on('select',this._updateBurnup, this);
        this.updateTimebox();
    },
    getUnit: function(){
        return this.down('#cbUnit') && this.down('#cbUnit').getValue() || this.chartUnits[0];
    },
    getTimeboxStartDate: function(){
        var record = this.getTimeboxRecord();
        return record.get(this.timeboxStartDateField);
    },
    getTimeboxEndDate: function(){
        var record = this.getTimeboxRecord();
        return record.get(this.timeboxEndDateField);
    },
    getTimeboxRecord: function(){
        var record = null;
        if (this.isOnScopedDashboard()){
            record = this.getContext().getTimeboxScope().getRecord();
        } else {
            record = this.down(this.timeboxTypePicker) && this.down(this.timeboxTypePicker).getRecord();
        }
        return record;
    },
    getTimeboxFilter: function(isForTimebox){
        var record = this.getTimeboxRecord();

        var prefix = isForTimebox ? "" : Ext.String.capitalize(this.timeboxType) + ".";

        if (record){
            return Rally.data.wsapi.Filter.and([
                {
                    property: prefix + 'Name',
                    value: record.get('Name')
                },
                {
                    property: prefix + this.timeboxStartDateField,
                    value: Rally.util.DateTime.toUtcIsoString(this.getTimeboxStartDate())
                },
                {
                    property: prefix + this.timeboxEndDateField,
                    value: Rally.util.DateTime.toUtcIsoString(this.getTimeboxEndDate())
                }
            ]);
        }
        return [];
    },
    updateTimebox: function(){
        var timeboxFilter = this.getTimeboxFilter();
        this.logger.log('updateTimebox', timeboxFilter.toString());

        this.releases = [];
        this.portfolioItems = [];

        if (!timeboxFilter || timeboxFilter.length === 0){
            this._showMissingCriteria();
            return;
        }
        this.setLoading(true);
        var promises = [Rally.technicalservices.Toolbox.fetchData({
            model: Ext.String.capitalize(this.timeboxType),
            fetch: ['ObjectID'],
            filters: this.getTimeboxFilter(true)
        }), Rally.technicalservices.Toolbox.fetchData({
            model: this.portfolioItemTypes[0],
            fetch: ['ObjectID','PreliminaryEstimate','Value'],
            context: {project: null},
            filters: timeboxFilter
        })];

        var me = this;
        Deft.Promise.all(promises).then({

            success: function(results){
                this.logger.log('updateTimebox Results', results);
                this.timeboxes = results[0];
                this.portfolioItems = results[1];
                this._updateBurnup();
            },
            failure: this._showError,
            scope: this
        }).always(function(){
            me.setLoading(false);
        });
    },
    onTimeboxScopeChange: function(timeboxScope){
        this.logger.log('onTimeboxScopeChange',timeboxScope);
        if (timeboxScope && timeboxScope.type === this.timeboxType){
            this.getContext().setTimeboxScope(timeboxScope);
            this.updateTimebox();
        }
    },
    _getFieldValueArray: function(records, fieldName){
        return _.map(records || [], function(r){ return r.get(fieldName); });
    },
    _showMissingCriteria: function(){
        this.down('#displayBox').removeAll();
        this.down('#displayBox').add({
            xtype: 'container',
            html: 'Please select a release filter.'
        });
    },
    _showError: function(msg){
        Rally.ui.notify.Notifier.showError({message: msg});
    },
    _updateBurnup: function(){
        this.logger.log('_updateBurnup', this.getUnit());

        if (!this.timeboxes || this.timeboxes.length === 0){
            this._showMissingCriteria();
            return;
        }

        this.down('#displayBox').removeAll();

        this.down('#displayBox').add({
            xtype: 'rallychart',
            chartColors: ['#8DC63F','#1E7C00','#7CAFD7','#666','#005EB8'],
            storeType: 'Rally.data.lookback.SnapshotStore',
            storeConfig: this._getStoreConfig(),
            calculatorType: 'Rally.technicalservices.ReleaseBurnupCalculator',
            calculatorConfig: {
                usePoints: this.getUnit() === 'Points',
                completedScheduleStateNames: this.completedStates,
                startDate: this.getTimeboxStartDate(),
                endDate: this.getTimeboxEndDate(),
                showPredictionLines: this.getShowPredictionLines()
                //preliminaryEstimateValueHashByObjectID: this.preliminaryEstimateValueHashByObjectID
            },
            chartConfig: this._getChartConfig()
        });
    },
    getShowPredictionLines: function(){
        return this.getSetting('showPredictionLines') === 'true' || this.getSetting('showPredictionLines') === true;
    },
    getShowDefects: function(){
        return this.getSetting('showDefects') === 'true' || this.getSetting('showDefects') === true ;
    },
    getShowStories: function(){
        var showStories = this.getSetting('showStories') === 'true' || this.getSetting('showStories') === true ;
        if (!this.getShowDefects()){
            return true;
        }
        return showStories;

    },
    _getStoreConfig: function(){

        var rOids = this._getFieldValueArray(this.timeboxes,'ObjectID'),
            piOids = this._getFieldValueArray(this.portfolioItems,'ObjectID'),
            projectOid = this.getContext().getProject().ObjectID;

        var typeHierarchy = [];
        if (this.getShowStories()){
            typeHierarchy.push('HierarchicalRequirement');
        }
        if (this.getShowDefects()){
            typeHierarchy.push('Defect');
        }
        if (typeHierarchy.length === 0){
            typeHierarchy = ['HierarchicalRequirement'];
        }

        var configs = [{
            find: {
                _TypeHierarchy: {$in: typeHierarchy},
                Children: null,
                Release: {$in: rOids} //We don't need project hierarchy here because the releases are associated with the current project hierarchy.
            },
            fetch: ['ScheduleState', 'PlanEstimate','_id'],
            hydrate: ['ScheduleState'],
            removeUnauthorizedSnapshots: true,
            sort: {
                _ValidFrom: 1
            },
            context: this.getContext().getDataContext(),
            limit: Infinity
        }];

        if (piOids && piOids.length > 0){
            configs.push({
                find: {
                        _TypeHierarchy: {$in: typeHierarchy},
                        Children: null,
                        _ItemHierarchy: {$in: piOids},
                        _ProjectHierarchy: projectOid // We need project hierarchy here to limit the stories and defects to just those in this project.
                },
                fetch: ['ScheduleState', 'PlanEstimate','_id'],
                hydrate: ['ScheduleState'],
                removeUnauthorizedSnapshots: true,
                sort: {
                    _ValidFrom: 1
                },
                context: this.getContext().getDataContext(),
                limit: Infinity
            });
        }
        return configs;
    },
    _getChartConfig: function(){
        return {
            chart: {
                defaultSeriesType: 'area',
                zoomType: 'xy'
            },
            title: {
                text: this.getTimeboxRecord() && this.getTimeboxRecord().get('Name') || "No Release",
                style: {
                    color: '#666',
                    fontSize: '18px',
                    fontFamily: 'ProximaNova',
                    fill: '#666'
                }
            },
            xAxis: {
                categories: [],
                tickmarkPlacement: 'on',
                tickInterval: 5,


                title: {
                    text: 'Date',
                    margin: 10,
                    style: {
                        color: '#444',
                        fontFamily:'ProximaNova',
                        textTransform: 'uppercase',
                        fill:'#444'
                    }
                },
                labels: {
                    style: {
                        color: '#444',
                        fontFamily:'ProximaNova',
                        textTransform: 'uppercase',
                        fill:'#444'
                    }
                }
            },
            yAxis: [
                {
                    title: {
                        text: this.getUnit(),
                        style: {
                            color: '#444',
                            fontFamily:'ProximaNova',
                            textTransform: 'uppercase',
                            fill:'#444'
                        }
                    },
                    labels: {
                        style: {
                            color: '#444',
                            fontFamily:'ProximaNova',
                            textTransform: 'uppercase',
                            fill:'#444'
                        }
                    }
                }
            ],
            legend: {
                itemStyle: {
                        color: '#444',
                        fontFamily:'ProximaNova',
                        textTransform: 'uppercase'
                },
                borderWidth: 0
            },
            tooltip: {
                backgroundColor: '#444',
                headerFormat: '<span style="display:block;margin:0;padding:0 0 2px 0;text-align:center"><b style="font-family:NotoSansBold;color:white;">{point.key}</b></span><table><tbody>',
                footerFormat: '</tbody></table>',
                pointFormat: '<tr><td class="tooltip-label"><span style="color:{series.color};width=100px;">\u25CF</span> {series.name}</td><td class="tooltip-point">{point.y}</td></tr>',
                shared: true,
                useHTML: true,
                borderColor: '#444'
            },
            plotOptions: {
                series: {
                    marker: {
                        enabled: false,
                        states: {
                            hover: {
                                enabled: true
                            }
                        }
                    },
                    groupPadding: 0.01
                },
                column: {
                    stacking: true,
                    shadow: false
                }
            }
        };
    },
    getOptions: function() {
        return [
            {
                text: 'About...',
                handler: this._launchInfo,
                scope: this
            }
        ];
    },
    getSettingsFields: function(){
        var labelWidth = 200;

        return [{
            xtype: 'rallycheckboxfield',
            fieldLabel: 'Show Prediction Lines',
            labelAlign: 'right',
            labelWidth: labelWidth,
            name: 'showPredictionLines'
        },{
            xtype: 'rallycheckboxfield',
            fieldLabel: 'Show Defects',
            labelAlign: 'right',
            labelWidth: labelWidth,
            name: 'showDefects'
        },{
            xtype: 'rallycheckboxfield',
            fieldLabel: 'Show User Stories',
            labelAlign: 'right',
            labelWidth: labelWidth,
            name: 'showStories'
        }];
    },
    _launchInfo: function() {
        if ( this.about_dialog ) { this.about_dialog.destroy(); }
        this.about_dialog = Ext.create('Rally.technicalservices.InfoLink',{});
    },
    
    isExternal: function(){
        return typeof(this.getAppId()) == 'undefined';
    },
    
    //onSettingsUpdate:  Override
    onSettingsUpdate: function (settings){
        this.logger.log('onSettingsUpdate',settings);
        // Ext.apply(this, settings);
        this.launch();
    }
});

            
               Rally.launchApp('release-burnup', {
                   name: 'Release Burnup'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width: 14px;
    height: 14px;
    border-radius: 7px;
    text-align: center;
    color: white;
    background: #C0C0C0;
    border-style: solid;
    border-width: 1px;
    margin-top: 25px;
    margin-right: 5px;
    cursor: pointer;
}
.highcharts-tooltip {
    font-family:NotoSansBold;
    color:white;
}
.tooltip-point {
    text-align: right;
    color: white;
}
.tooltip-label {
    font-family:NotoSans;
    white-space:nowrap;
    font-size:13px;
    color:white;
}
    </style>

</head>
<body></body>
</html>